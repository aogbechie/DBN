{
    "collab_server" : "",
    "contents" : "readTimeSerie <- function(filepaths,pixels) {\n  #Function that returns a list of vectors. Where each vector is the time serie of a pixel \n  #for a certain operation sequence.\n  \n  num_files<-length(filepaths)\n  num_pixels<-length(pixels)\n  \n  #If we do not have any filepath we exit the function, else we read each file\n  if(num_files==0 || num_pixels==0){\n    print(\"Please, specify the paths to read or the pixels\")\n    return (0)\n  } else {\n    dataset=list() #Initialize the dataset\n    #choose only the selected pixels\n    pixel_select<-rep(\"NULL\", 1025)\n    for(pixel in pixels){\n      pixel_select[pixel]<-\"integer\"\n    }\n    #read the files\n    for(file in filepaths){\n      mydata <- read.table(file, header=FALSE, sep=\";\", colClasses=pixel_select)\n      mydata<-list(mydata)\n      dataset<-c(dataset,mydata)\n    }\n    return(dataset)\n  }\n  \n}#END readTimeSerie\n\nequalLengthDiscr<- function(dataset, breaks, levels_factor) {\n  #Function to discretize each dataset in a fix number of bins. \n  #For this implementation the range is from 0 to 1024\n  init <- 0\n  end <- 1024\n  edges <- seq(from = init, by = (end/breaks), length.out = (breaks +1))\n  label <- levels_factor\n  n_seqs <- length(dataset)\n  n_vars<-length(dataset[[1]])\n  \n  for (i in 1:n_seqs){\n    df<-dataset[[i]]\n    df_numeric<-sapply(df,as.numeric)\n    for (j in 1:n_vars ){\n      v <- df_numeric[,j]\n      v <- cut(v,breaks=edges,labels = label, include.lowest=TRUE)\n      #v <- cut(v,breaks=edges,labels = FALSE, include.lowest=TRUE)\n      df_numeric[,j] <- v\n    }\n    df <- data.frame(df_numeric)\n    df <- sapply(df,as.integer)\n    df <- data.frame(df)\n    dataset[[i]] <- df\n  }\n  return(dataset)\n}#END equalLengthDiscr\n\nseparateDatasetDBN <- function(dataset,criteria, breaks) {\n  #Function to separate the dataset in CPC_0, CPC_t, PC_t, CC_t\n  n_seqs<-length(dataset)\n  n_vars<-length(dataset[[1]])\n  #Obtain CPC_0\n  switch(criteria, \n         CPC_0={\n           # case 'CPC_0' here...\n           cpc_0<-dataset[[1]][1,]\n           for (i in 1:n_seqs) {\n             cpc_0<-rbind(cpc_0,dataset[[i]][1,])\n           }\n           cpc_0=cpc_0[-1,]\n           names(cpc_0)<-paste(names(dataset[[1]]),\"_0\",sep=\"\")\n           cpc_0<-data.frame(sapply(cpc_0,as.numeric)) #Must be in numeric & dataframe for the algorithm\n           return(cpc_0)\n         },\n         CPC_t={\n           # case 'CPC_t' here...\n           cpc_t<-dataset[[1]][1,]\n           for (i in 1:n_seqs) {\n             cpc_t<-rbind(cpc_t,dataset[[i]][-1,])\n           }\n           cpc_t=cpc_t[-1,]\n           names(cpc_t)<-paste(names(dataset[[1]]),\"_t\",sep=\"\")\n           if(is.null(breaks)){\n             cpc_t<-data.frame(sapply(cpc_t,as.numeric)) \n           }else{\n             ###assure that we have num_factors= breaks in the correct order\n             cpc_t <- int2factor_breaks(cpc_t,breaks)\n           }\n           return(cpc_t)    \n         },\n         PC_t={\n           # case 'PC_t' here...\n           pc_t<-cbind(dataset[[1]][1,],dataset[[1]][1,])\n           for (i in 1:n_seqs) {\n             n_slices<-length(dataset[[i]][,1])\n             pc_int_t=dataset[[i]][-1,]\n             pc_int_tpast=dataset[[i]][-n_slices,]\n             pc_int<-cbind(pc_int_t,pc_int_tpast)\n             pc_t<-rbind(pc_t,pc_int)\n           }\n           pc_t=pc_t[-1,]\n           names(pc_t)<-c(paste(names(dataset[[1]]),\"_t\",sep=\"\"),paste(names(dataset[[1]]),\"_tpast\",sep=\"\"))\n           if(is.null(breaks)){\n             pc_t<-data.frame(sapply(pc_t,as.numeric)) \n           }else{\n             ###assure that we have num_factors= breaks in the correct order\n             pc_t <- int2factor_breaks(pc_t,breaks)\n           }\n           return(pc_t)         \n         },\n         CC_t={\n           # case 'CC_t' here...\n           cc_t<-cbind(dataset[[1]][1,],dataset[[1]][1,])\n           for (i in 1:n_seqs) {\n             n_slices<-length(dataset[[i]][,1])\n             cc_int_t=dataset[[i]][-n_slices,]\n             cc_int_tnext=dataset[[i]][-1,]\n             cc_int<-cbind(cc_int_t,cc_int_tnext)\n             cc_t<-rbind(cc_t,cc_int)\n           }\n           cc_t=cc_t[-1,]\n           names(cc_t)<-c(paste(names(dataset[[1]]),\"_t\",sep=\"\"),paste(names(dataset[[1]]),\"_tnext\",sep=\"\"))\n           if(is.null(breaks)){\n             cc_t<-data.frame(sapply(cc_t,as.numeric)) \n           }else{\n             ###assure that we have num_factors= breaks in the correct order\n             cc_t <- int2factor_breaks(cc_t,breaks)\n           }\n           return(cc_t)     \n         },\n         {\n           print('Please state valid criteria')\n         }\n  )\n}#END separateDatasetDBN\n\nint2factor_breaks <- function(dataset, breaks){\n  ###assure that we have num_factors= breaks in the correct order\n  n_vars<-length(dataset)\n  correct_factor <- dataset[1,]\n  for (i in 1:breaks){\n    factor_in <- rep(i,n_vars) \n    correct_factor <- rbind(correct_factor,factor_in)\n  }\n  correct_factor<-correct_factor[-1,]\n  dataset <- rbind(correct_factor, dataset)\n  ###\n  dataset_factor<-as.data.frame(matrix(NA, nrow = nrow(dataset), ncol = ncol(dataset)))\n  for(i in 1:ncol(dataset)){\n    dataset_factor[,i] <- factor(dataset[,i], levels = 1:breaks, labels = 1:breaks, ordered = TRUE)\n  }\n  names(dataset_factor)<-names(dataset)\n  ###\n  dataset_factor <- dataset_factor[-(1:breaks),]\n  \n  return(dataset_factor)\n}\n\n\nwhitelist_CPC <- function(cpc, nodes_t) {\n  white <- data.frame()\n  for (i in 1:length(nodes_t)){\n    node_name <-names(cpc[i])\n    node_nbr <- cpc[[i]][2]$nbr\n    \n    node_nbr <- node_nbr[node_nbr %in% nodes_t]\n    \n    for (neighbour_node in node_nbr){\n      white <- rbind(white, data.frame(from = c(node_name, neighbour_node), to = c(neighbour_node, node_name)))\n    }\n  }\n  return(white)\n}\n\nin.t <- function(cpc, nodes_t) {\n  \n  for (i in 1:length(nodes_t)){\n    node_name <-names(cpc[i])\n    node_nbr <- cpc[[i]][2]$nbr\n    node_nbr <- node_nbr[node_nbr %in% nodes_t]\n    cpc[[i]][2]$nbr <- node_nbr\n  }\n  return(cpc)\n}\n\nblacklist_notCPC <- function(cpc, nodes_t) {\n  black <- data.frame()\n  for (i in 1:length(nodes_t)){\n    node_name <-names(cpc[i])\n    node_nbr <- cpc[[i]][2]$nbr\n    node_not_nbr <- nodes_t[! nodes_t %in% node_nbr]\n    \n    for (not_neighbour_node in node_not_nbr){\n      black <- rbind(black, data.frame(from = c(node_name, not_neighbour_node), to = c(not_neighbour_node, node_name)))\n    }\n  }\n  return(black)\n}\n\nblacklistDMMPC <- function(data, nodes) {\n  cpc<- data[[1]]\n  pc <- data[[2]]\n  nodes_t <- names(cpc)\n  nodes_past <- nodes[! nodes %in% nodes_t]\n  \n  blacklist <- data.frame()\n \n  \n  #1. blacklist CPC\n  for (i in 1:length(nodes_t)){\n    node_name <-names(cpc[i])\n    node_nbr <- cpc[[i]]\n    node_not_nbr <- nodes_t[! nodes_t %in% node_nbr]\n    \n    for (not_neighbour_node in node_not_nbr){\n      blacklist <- rbind(blacklist, data.frame(from = c(node_name, not_neighbour_node), to = c(not_neighbour_node, node_name)))\n    }\n  }\n  \n  #2. blacklist from present to past\n  for (i in 1:length(nodes_t)){\n    node_name_present <-names(cpc[i])\n    for (j in 1:length(nodes_past)) {\n      node_name_past <- nodes_past[j]\n      blacklist <- rbind(blacklist, data.frame(from = node_name_present, to = node_name_past))\n    }\n  }\n  \n  #3. blacklist inter past-present\n  for (i in 1:length(nodes_t)){\n    node_name <-names(cpc[i])\n    node_nbr <- pc[[i]]\n    node_not_nbr <- nodes_past[! nodes_past %in% node_nbr]\n    \n    for (not_neighbour_node in node_not_nbr){\n      blacklist <- rbind(blacklist, data.frame(from = not_neighbour_node, to = node_name))\n    }\n  }\n  \n  #4. blacklist intra past\n  node_iter <- nodes_past\n  for (i in 1:length(nodes_past)) {\n    node_name <-nodes_past[i]\n    for (j in 1:length(node_iter)) {\n      node_name_j <-node_iter[j]\n      blacklist <-rbind(blacklist, data.frame(from = c(node_name,node_name_j), to = c(node_name_j,node_name)))\n    }\n    node_iter <- node_iter[-1]\n  }\n  \n  blacklist<-blacklist[!duplicated(blacklist),]\n  return(blacklist)\n}\n\nbic_dbn <- function(data_past, complete_score, score) {\n  nodes_past <- names(data_past)\n  node_iter <- nodes_past\n  blacklist <- data.frame()\n  for (i in 1:length(nodes_past)) {\n    node_name <-nodes_past[i]\n    for (j in 1:length(node_iter)) {\n      node_name_j <-node_iter[j]\n      blacklist <-rbind(blacklist, data.frame(from = c(node_name,node_name_j), to = c(node_name_j,node_name)))\n    }\n    node_iter <- node_iter[-1]\n  }\n  blacklist<-blacklist[!duplicated(blacklist),]\n  bn_past=hc(data_past,blacklist = blacklist, score = score)\n  score_past=score(bn_past,data_past, type = score)\n  score_dbn=complete_score-score_past\n  return(score_dbn) \n}\n\nloglik.dbn <- function(data_past, complete_score, score) {\n  nodes_past <- names(data_past)\n  node_iter <- nodes_past\n  blacklist <- data.frame()\n  for (i in 1:length(nodes_past)) {\n    node_name <-nodes_past[i]\n    for (j in 1:length(node_iter)) {\n      node_name_j <-node_iter[j]\n      blacklist <-rbind(blacklist, data.frame(from = c(node_name,node_name_j), to = c(node_name_j,node_name)))\n    }\n    node_iter <- node_iter[-1]\n  }\n  blacklist<-blacklist[!duplicated(blacklist),]\n  bn_past=hc(data_past,blacklist = blacklist, score = score)\n  score_past=score(bn_past,data_past, type = score)\n  score_dbn=complete_score-score_past\n  return(score_dbn) \n}\n\ntwo_tbn.plot <- function(bn_trans, n_nodes){\n  nodes_t<-names(bn_trans[[2]])[1:n_nodes]\n  nodes_tpast<-names(bn_trans[[2]])[-(1:n_nodes)]\n  nodes1 <-nodes_tpast\n  nodes2 <-nodes_t  \n  ft <- bn_trans$arcs\n  ft <- ft[!duplicated(apply(ft, 1, paste, collapse=\"\")),]\n  back1<-sapply(nodes1,function(x){ x %in% ft})\n  nodes1 <- subset(nodes1,back1)\n  back2<-sapply(nodes2,function(x){ x %in% ft})\n  nodes2 <- subset(nodes2,back2)\n  g <- ftM2graphNEL(ft, edgemode=\"directed\")\n  twocolors <- c(\"transparent\", \"#E0F3F8\")\n  nodeType <- 1 + (nodes(g) %in% nodes1)\n  nA = makeNodeAttrs(g, fillcolor=twocolors[nodeType])\n  sg1 = subGraph(nodes1, g)\n  sgL = list(list(graph=sg1, cluster = FALSE, attrs = c(rank=\"sink\")))\n  att = list(graph = list(rankdir = \"RL\", rank = \"\"))\n  #plot(g, attrs = att, nodeAttrs=nA, subGList = sgL)\n  \n  #nodes not used\n  nodes_used <- c(ft[,1],ft[,2])\n  black_t <- sapply(nodes_t, function(x){x %in% nodes_used})\n  innecessary_t <-names(black_t[! black_t])\n  print(\"Innecesary variables in t\")\n  print(innecessary_t)\n  black_tpast <- sapply(nodes_tpast, function(x){x %in% nodes_used})\n  innecessary_tpast <-names(black_tpast[! black_tpast])\n  print(\"Innecesary variables in t-1\")\n  print(innecessary_tpast)\n  \n  return(list(g, att, nA, sgL))\n  \n}\n  ",
    "created" : 1458664919257.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1428324858",
    "id" : "DD2CA12E",
    "lastKnownWriteTime" : 1458557479,
    "last_content_update" : 1458557479,
    "path" : "~/sources/bnlearn/R/aa_01Laser_DataPreprocessing.R",
    "project_path" : "R/aa_01Laser_DataPreprocessing.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}